# 缓存

## 作用

​	缓存最大的作用是提升数据操作效率（内存），减轻数据库访问的压力（磁盘）。



## 缓存问题

​	引入缓存，可以提升系统的响应速度和系统吞吐量，但也会使系统变得比之前更复杂，带来相应的缓存问题。



### 缓存击穿

​	缓存击穿是指访问**缓存中没有而数据库中存在**的数据（一般是缓存过期）。

​	缓存击穿和缓存雪崩有点像，缓存雪崩是同一时间大面积缓存失效，而缓存击穿是一个热点Key失效，在高并发访问下大量请求通过这个Key击穿到数据库，造成巨大压力，这就是缓存击穿。



**解决方案：**

- 设置热点数据永不过期；





### 缓存雪崩

​	当缓存服务器重启、宕机，或大量缓存数据同一个时间大面积失效，也会给数据库造成巨大压力，这便是缓存雪崩。





<img src="..\md_resource\image-20200228222928677.png" alt="image-20200228222928677" style="zoom:67%;" />

**解决方案：**

- 在批量存数据的时候，把每个Key的失效时间多加一个随机值就OK了；
- 或者设置热点数据永不过期；
- 如果Redis是集群部署，将热点数据均匀分布在不同的服务器中也能避免全部失效；



### 缓存穿透

​	缓存穿透是指访问**缓存和数据库都不存在**的数据。

​	由于缓存不命中时需要从数据库查，数据库也查不到则不写入缓存，导致每次查询这个不存在的数据都要穿透到数据库，给数据库造成压力。



<img src="..\md_resource\image-20200228222948811.png" alt="image-20200228222948811" style="zoom:67%;" />



**解决方案：**

- 在接口层增加校验逻辑；
- 使用布隆过滤器判断数据是否存在；





### 缓存与数据库一致性

​	分布式环境容易出现缓存和数据库数据不一致的情况，针对这一点，如果项目对缓存要求数据强一致，那么就不要使用缓存。我们只能采取合适的策略降低缓存和数据库数据不一致的概率，而无法保证两者数据强一致。

​	

这取决于到底是先更新缓存，还是先更新数据库：

- 先更新数据库，再更新缓存
- 先更新缓存，再更新数据库
- 先更新数据库，再删除缓存
- 先删除缓存，再更新数据库



推荐 先更新数据库，再删除缓存；




## 缓存淘汰策略

Redis服务器的内存容量是有限的，不可能只增不删，因此需要淘汰缓存。

Redis 有两种缓存淘汰策略：

- 为缓存设置过期时间；
- 采用LRU算法自动淘汰缓存；

### 设置过期时间

```
expire key_name time;
```



### LRU算法自动删除数据

​	LRU是Least Recently Used的缩写，即**最近最少使用**，是一种常用的页面置换算法。

​	Redis4.0版本提供6种淘汰策略，Redis5.0版本提供8种淘汰策略；



-  **volatile-lru** ：在已设定超时时间的数据中，删除最近最少使用的数据；
   **allkeys-lru  ： 在所有key中，删除最近最少使用的数据，这是应用最广泛的策略；**
-  volatile-random ：在已设定超时时间的数据中，随机删除；
   allkeys-random  ：在所有key中，随机删除数据；

-  volatile-ttl ：在已设定超时时间的数据中，排序然后删除最快过期的数据；
   noeviction ：如果设置该属性，则不会进行删除操作，如果内存溢出则报错返回；（默认策略）

-  volatile-lfu ：在已设定超时时间的数据中，删除最少使用的数据；
   allkeys-lfu  ：在所有key中，删除最少使用的数据；



​	LRU （最近最少使用算法）和 LFU （最少使用算法）都是页面置换算法，LRU是Redis最早支持的内存淘汰策略，LFU是Redis5.0版本引入的。



Redis的默认策略是`noeviction` ，即不淘汰数据。



